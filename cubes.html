<!DOCTYPE html>
<html lang="fr">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Three.js + Ammo.js (CDN) — Factions & Agents autonomes v2</title>
		<style>
			html,
			body {
				margin: 0;
				height: 100%;
				background: #0b0e13;
				color: #eaeaea;
				font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
					Cantarell, Noto Sans, sans-serif;
			}
			#app {
				position: fixed;
				inset: 0;
			}
			.ui {
				position: fixed;
				left: 12px;
				top: 12px;
				padding: 10px 12px;
				border-radius: 12px;
				background: rgba(0, 0, 0, 0.45);
				backdrop-filter: blur(6px);
				font-size: 14px;
				line-height: 1.4;
				max-width: 390px;
			}
			.pass {
				color: #9f9;
			}
			.fail {
				color: #f99;
			}
			kbd {
				background: #504c4c;
				border: 1px solid #333;
				border-bottom-width: 2px;
				border-radius: 4px;
				padding: 0 4px;
			}
			a {
				color: #9ad;
			}
		</style>

		<script type="importmap">
			{
				"imports": {
					"three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.min.js",
					"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/"
				}
			}
		</script>

		<script src="https://cdn.jsdelivr.net/npm/@cocos/ammo@1.2.0/builds/ammo.wasm.js"></script>

		<script type="module">
			import * as THREE from "three";
			import { OrbitControls } from "three/addons/controls/OrbitControls.js";

			Ammo().then((AmmoLib) => {
				// ----------------------
				// 0) CONSTANTES & CACHES (réduction allocations)
				// ----------------------
				const MAX_PIXEL_RATIO = 1.5; // éviter VRAM élevée
				const TMP = {
					trans: new AmmoLib.btTransform(),
					vA: new AmmoLib.btVector3(0, 0, 0),
					vB: new AmmoLib.btVector3(0, 0, 0),
					one: new AmmoLib.btVector3(1, 1, 1),
					zero: new AmmoLib.btVector3(0, 0, 0),
					angY: new AmmoLib.btVector3(0, 1, 0),
				};
				const T3 = {
					// temporaires Three.js réutilisés
					v1: new THREE.Vector3(),
					v2: new THREE.Vector3(),
					q1: new THREE.Quaternion(),
				};
				// Géométries partagées (évite de dupliquer les buffers)
				const GEOS = {
					box: new THREE.BoxGeometry(1, 1, 1),
					pyramid: new THREE.CylinderGeometry(0, 0.7, 1, 4),
					sphere: new THREE.SphereGeometry(0.5, 24, 16),
					ground: null, // créé plus bas avec la bonne taille
				};

				// ----------------------
				// 1) MOTEUR PHYSIQUE
				// ----------------------
				const collisionConfiguration =
					new AmmoLib.btDefaultCollisionConfiguration();
				const dispatcher = new AmmoLib.btCollisionDispatcher(
					collisionConfiguration
				);
				const broadphase = new AmmoLib.btDbvtBroadphase();
				const solver = new AmmoLib.btSequentialImpulseConstraintSolver();
				const physicsWorld = new AmmoLib.btDiscreteDynamicsWorld(
					dispatcher,
					broadphase,
					solver,
					collisionConfiguration
				);
				physicsWorld.setGravity(new AmmoLib.btVector3(0, -9.81, 0));

				// ----------------------
				// 2) SCÈNE THREE.JS
				// ----------------------
				const renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(
					Math.min(devicePixelRatio || 1, MAX_PIXEL_RATIO)
				);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.shadowMap.enabled = true;
				document.body.appendChild(renderer.domElement);

				const scene = new THREE.Scene();
				scene.background = new THREE.Color(0x0b0e13);

				const camera = new THREE.PerspectiveCamera(
					60,
					innerWidth / innerHeight,
					0.1,
					500
				);
				camera.position.set(6, 7, 12);

				const controls = new OrbitControls(camera, renderer.domElement);
				renderer.domElement.style.display = "block";
				renderer.domElement.style.position = "fixed";
				renderer.domElement.style.inset = "0";
				renderer.domElement.style.touchAction = "none";
				controls.enableDamping = true;
				controls.enableRotate = true;
				controls.enableZoom = true;
				controls.enablePan = true;
				controls.screenSpacePanning = false;
				controls.minPolarAngle = 0.0;
				controls.maxPolarAngle = Math.PI / 2 - 0.01;
				controls.minDistance = 2;
				controls.maxDistance = 80;
				controls.mouseButtons = {
					LEFT: THREE.MOUSE.ROTATE,
					MIDDLE: THREE.MOUSE.DOLLY,
					RIGHT: THREE.MOUSE.PAN,
				};
				controls.touches = {
					ONE: THREE.TOUCH.ROTATE,
					TWO: THREE.TOUCH.DOLLY_PAN,
				};
				controls.target.set(0, 1, 0);
				function clampCameraAboveGround(minY = 0.05) {
					if (camera.position.y < minY) camera.position.y = minY;
					if (controls.target.y < minY * 0.5)
						controls.target.y = minY * 0.5;
				}
				clampCameraAboveGround();
				controls.addEventListener("change", () => clampCameraAboveGround());

				// Lumières
				scene.add(new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6));
				const dir = new THREE.DirectionalLight(0xffffff, 1);
				dir.position.set(5, 10, 5);
				dir.castShadow = true;
				dir.shadow.mapSize.set(1024, 1024);
				scene.add(dir);

				// ----------------------
				// 3) OUTILS / STRUCTURES
				// ----------------------
				let LOCK_MODE = false; // "tourelles": position figée, rotation uniquement autour de Y (sol->ciel)

				function setLockMode(enabled) {
					LOCK_MODE = enabled;
					for (const a of agents) applyLockToAgent(a, enabled);
					const badge = document.getElementById("lockBadge");
					if (badge)
						badge.textContent = LOCK_MODE
							? "Lock: ON (rotation Y seulement)"
							: "Lock: OFF";
				}

				function applyLockToAgent(agent, enabled, snap = true) {
					const b = agent.body;
					if (!b) return;
					if (enabled) {
						if (!agent.anchor)
							agent.anchor = new THREE.Vector3(
								agent.mesh.position.x,
								0.5,
								agent.mesh.position.z
							);
						b.setLinearFactor(TMP.zero);
						b.setAngularFactor(TMP.angY);
						b.setLinearVelocity(TMP.zero);
						b.setAngularVelocity(TMP.zero);
						// Optionnel: Snap à l'ancre (x,z) et à y=0.5 — désactivable (snap=false)
						if (snap) {
							const tr = TMP.trans;
							b.getMotionState().getWorldTransform(tr);
							tr.setOrigin(
								new AmmoLib.btVector3(
									agent.anchor.x,
									agent.anchor.y ?? 0.5,
									agent.anchor.z
								)
							);
							if (typeof b.setWorldTransform === "function")
								b.setWorldTransform(tr);
							else if (typeof b.setCenterOfMassTransform === "function")
								b.setCenterOfMassTransform(tr);
						}
						if (typeof b.activate === "function") b.activate();
					} else {
						b.setLinearFactor(TMP.one);
						b.setAngularFactor(TMP.one);
						if (typeof b.activate === "function") b.activate();
					}
				}

				const rigidBodies = [];
				const agents = []; // {mesh, body, faction, role, headingDeg, speed, turnRate, grounded, hp, energy, state, hat, anchor}
				const resources = []; // {mesh, pos}
				const factionCounts = new Map(); // id -> count (max 3)

				function createRigidBody(
					mesh,
					shape,
					mass = 0,
					pos = mesh.position,
					quat = mesh.quaternion
				) {
					const transform = new AmmoLib.btTransform();
					transform.setIdentity();
					transform.setOrigin(new AmmoLib.btVector3(pos.x, pos.y, pos.z));
					transform.setRotation(
						new AmmoLib.btQuaternion(quat.x, quat.y, quat.z, quat.w)
					);
					const motionState = new AmmoLib.btDefaultMotionState(transform);
					const localInertia = new AmmoLib.btVector3(0, 0, 0);
					if (mass > 0) shape.calculateLocalInertia(mass, localInertia);
					const rbInfo = new AmmoLib.btRigidBodyConstructionInfo(
						mass,
						motionState,
						shape,
						localInertia
					);
					const body = new AmmoLib.btRigidBody(rbInfo);
					body.setFriction(0.9);
					body.setRollingFriction(0.2);
					body.setDamping(0.3, 0.5);
					physicsWorld.addRigidBody(body);
					mesh.userData.physicsBody = body;
					mesh.userData.shape = shape; // utile si on veut nettoyer plus tard
					mesh.castShadow = true;
					mesh.receiveShadow = true;
					// mesh.receiveShadow = mass === 0;
					if (mass > 0) rigidBodies.push(mesh);
					// Libère rbInfo & localInertia (transform est référencé par motionState)
					AmmoLib.destroy(rbInfo);
					AmmoLib.destroy(localInertia);
					return body;
				}

				function setVelocity(body, vx, vy, vz) {
					TMP.vA.setValue(vx, vy, vz);
					if (typeof body.setLinearVelocity === "function") {
						body.setLinearVelocity(TMP.vA);
					} else {
						// fallback: impulser vers la vitesse désirée
						const k = 0.2; // gain
						TMP.vB.setValue(vx * k, vy * k, vz * k);
						body.applyCentralImpulse(TMP.vB);
					}
					if (typeof body.activate === "function") body.activate();
				}

				function kickBody(body, vec3) {
					try {
						if (typeof body.applyCentralImpulse === "function") {
							body.applyCentralImpulse(vec3);
							return;
						}
						if (typeof body.applyImpulse === "function") {
							const zero = TMP.vB;
							zero.setValue(0, 0, 0);
							body.applyImpulse(vec3, zero);
							return;
						}
						if (typeof body.setLinearVelocity === "function") {
							body.setLinearVelocity(vec3);
							return;
						}
						if (typeof body.applyCentralForce === "function") {
							body.applyCentralForce(vec3);
							if (typeof body.activate === "function") body.activate();
						}
					} catch (e) {
						console.warn(e);
					}
				}

				// 4 factions (couleurs uniques)
				const FACTIONS = [
					{ id: 0, name: "Aqua", color: 0x49b6ff },
					{ id: 1, name: "Ember", color: 0xff6b57 },
					{ id: 2, name: "Moss", color: 0x57e389 },
					{ id: 3, name: "Amethyst", color: 0xb085ff },
				];

				// Création du "chapeau" visuel indiquant le rôle (aucune collision)
				function addRoleHat(parentMesh, roleKey) {
					let hatGeo;
					if (roleKey === "tank") hatGeo = GEOS.box; // cube
					else if (roleKey === "dps") hatGeo = GEOS.pyramid; // pyramide
					else hatGeo = GEOS.sphere; // healer -> sphère
					const hat = new THREE.Mesh(
						hatGeo,
						new THREE.MeshStandardMaterial({
							color: 0xffffff,
							metalness: 0.1,
							roughness: 0.6,
						})
					);
					hat.name = "roleHat";
					hat.castShadow = true;
					hat.receiveShadow = true;
					// taille réduite; la position sera recalculée chaque frame pour rester au-dessus en Y monde
					hat.scale.set(0.55, 0.55, 0.55);
					hat.position.set(0, 0.85, 0); // valeur initiale, corrigée ensuite par updateHat()
					parentMesh.add(hat);
					return hat;
				}

				// Maintenir le chapeau au-dessus en Y monde, sans hériter de la rotation du cube
				function updateHat(agent) {
					const mesh = agent.mesh;
					const hat =
						agent.hat || mesh.children.find((c) => c.name === "roleHat");
					if (!hat) return;
					agent.hat = hat; // cache

					// 1) Position : world(mesh) + (0, offset, 0) → converti en local(parent)
					const offsetY = 0.85;
					T3.v1.set(0, offsetY, 0);
					mesh.getWorldPosition(T3.v2).add(T3.v1);
					mesh.worldToLocal(T3.v2); // v2 devient pos locale du chapeau
					hat.position.copy(T3.v2);

					// 2) Orientation : annuler la rotation du parent pour garder le chapeau "droit"
					mesh.getWorldQuaternion(T3.q1).invert();
					hat.quaternion.copy(T3.q1);
				}

				// Aligner physiquement l'orientation (yaw) sur la direction de déplacement (ou le heading en lock)
				function faceMotion(a, dt) {
					// Limite / vitesse de rotation max (rad/s)
					const maxYawRate = (a.turnRate * Math.PI) / 180; // ex: 160°/s

					// 1) Calcul du yaw cible
					let targetYaw;
					if (!LOCK_MODE) {
						const v = a.body.getLinearVelocity();
						const vx = typeof v.x === "function" ? v.x() : v.x ?? 0;
						const vz = typeof v.z === "function" ? v.z() : v.z ?? 0;
						if (Math.abs(vx) + Math.abs(vz) > 1e-3) {
							targetYaw = Math.atan2(vx, vz);
						}
					}
					if (targetYaw == null) {
						targetYaw = (a.headingDeg * Math.PI) / 180;
					}

					// 2) Yaw courant (déduit du quaternion de la mesh déjà sync avec la physique)
					const e = new THREE.Euler().setFromQuaternion(
						a.mesh.quaternion,
						"YXZ"
					);
					const yaw = e.y;

					// 3) Erreur et vitesse angulaire désirée
					let diff =
						THREE.MathUtils.euclideanModulo(
							targetYaw - yaw + Math.PI,
							Math.PI * 2
						) - Math.PI; // [-PI,PI]
					const desiredRate = THREE.MathUtils.clamp(
						diff / Math.max(dt, 1e-3),
						-maxYawRate,
						maxYawRate
					);

					// 4) Appliquer côté physique (Y uniquement)
					a.body.setAngularFactor(TMP.angY);
					TMP.vA.setValue(0, desiredRate, 0);
					a.body.setAngularVelocity(TMP.vA);
					if (typeof a.body.activate === "function") a.body.activate();
				}

				
				// ----------------------
				// Skills => Pouvoirs disponibles 
				// ----------------------
				const SKILLS = {
					tir: {
						// tire un projectile de sa couleur droit devant
						lv: 1,
						distance: 10, // distance de tir
						effet : {
							malus : {
								degats: 5,// degats occasionés si touché
								repeat: false
							}
						}, 
						rayon: false, // non applicable
						duree: false, // non applicable car le projectile disparait une fois arrivé à la distance max
						energie: 5, // 5 pts d'energie sont nécessaire pour lancer tir lv 1
						rechargement: 5, // delai pour relancer ce skill en sec
					},
					bouclier:  {
						// une sphère semi transparente protegeant les membres de la faction présent dans la sphere pendant 5 sec (bonus +20 en def)
						lv: 1,
						distance: 0, // distance (sur lui meme)
						effet : {
							bonus : {
								def: 20,// défense améliorée
								repeat: false
							}
						},
						rayon: 8, // rayon de la sphere dans la quelle l'effet est appliqué.
						duree: 5, // durée du sort en secondes
						energie: 20, // 20 pts d'energie sont nécessaire pour lancer bouclier lv 1
						rechargement: 5, // delai pour relancer ce skill en sec
					},
					soin:  {
						// une sphère semi transparente apparait pendant 5 sec soignant les membres de la faction présent dans la sphere (bonus +5 en vie / seconde)
						lv: 1,
						distance: 0, // distance (sur lui meme)
						effet : {
							bonus : {
								vie: 5,// soigne
								repeat: 1 // le sort se repete toutes les x secondes jusqua la fin du skill
							}
						},
						rayon: 6, // rayon de la sphere dans la quelle l'effet est appliqué.
						duree: 5, // durée du sort en secondes
						energie: 20, // 20 pts d'energie sont nécessaire pour lancer soin lv 1
						rechargement: 5, // delai pour relancer ce skill en sec
					},
				}
				// ----------------------
				// Rôles => **corps physiques identiques (cubes)** + chapeau visuel au-dessus
				// ----------------------
				const ROLES = {
					tank: {
						def: 10,
						mass: 1.6,
						speed: 2.0,
						energie: 99,
						turn: 110,
						makeMesh: () => GEOS.box,
						makeShape: () =>
							new AmmoLib.btBoxShape(
								new AmmoLib.btVector3(0.5, 0.5, 0.5)
							),
					},
					dps: {
						def: 6,
						mass: 1.0,
						speed: 3.0,
						energie: 99,
						turn: 160,
						makeMesh: () => GEOS.box,
						// Tous des cubes côté physique pour homogénéité
						makeShape: () =>
							new AmmoLib.btBoxShape(
								new AmmoLib.btVector3(0.5, 0.5, 0.5)
							),
					},
					healer: {
						def: 5,
						mass: 0.8,
						speed: 2.4,
						energie: 99,
						turn: 180,
						makeMesh: () => GEOS.box,
						makeShape: () =>
							new AmmoLib.btBoxShape(
								new AmmoLib.btVector3(0.5, 0.5, 0.5)
							),
					},
				};

				function canSpawnFaction(fid) {
					const c = factionCounts.get(fid) || 0;
					return c < 3; // cap 3 par faction
				}
				function incFaction(fid) {
					factionCounts.set(fid, (factionCounts.get(fid) || 0) + 1);
				}

				function spawnAgent(roleKey, factionIndex, x, y, z) {
					console.log("roleKey",roleKey)
					const role = ROLES[roleKey];
					const fac = FACTIONS[factionIndex % FACTIONS.length];
					if (!canSpawnFaction(fac.id)) return null; // cap 3 par faction
					const geom = role.makeMesh();
					const mat = new THREE.MeshStandardMaterial({
						color: fac.color,
						metalness: 0.1,
						roughness: 0.7,
					});
					const mesh = new THREE.Mesh(geom, mat);
					mesh.position.set(x, y, z);
					scene.add(mesh);
					// Ajoute le chapeau visuel selon le rôle
					const hat = addRoleHat(mesh, roleKey);
					const shape = role.makeShape();
					const body = createRigidBody(mesh, shape, role.mass);
					// Ne permettre que la rotation Y pour éviter roulis/tangage incohérents
					if (typeof body.setAngularFactor === "function")
						body.setAngularFactor(TMP.angY);
					if (typeof body.setActivationState === "function")
						body.setActivationState(4);
					if (typeof body.activate === "function") body.activate();
					TMP.vA.setValue(
						(Math.random() - 0.5) * 2,
						-1,
						(Math.random() - 0.5) * 2
					);
					kickBody(body, TMP.vA);
					const agent = {
						mesh,
						body,
						hat,
						faction: fac.id,
						role: roleKey,
						headingDeg: Math.random() * 360,
						speed: role.speed,
						turnRate: role.turn,
						grounded: false,
						hp: 66,
						energy: 99,
						state: "wander",
						thinkT: 0,
						turnT: 0,
						anchor: new THREE.Vector3(x, 0.5, z),
					};
					agents.push(agent);
					incFaction(fac.id);
					return agent;
				}

				// Ressources (petites billes rouges)
				const RES_COLOR = 0xff3b30;
				const RES_R = 0.2;
				const RES_PICK = 0.7;
				const RES_HEAL = 20;
				function spawnResource(x, z) {
					const y = 0.5;
					const geo = new THREE.SphereGeometry(RES_R, 16, 12);
					const mat = new THREE.MeshStandardMaterial({
						color: RES_COLOR,
						emissive: 0x330000,
						emissiveIntensity: 0.35,
					});
					const m = new THREE.Mesh(geo, mat);
					m.position.set(x, y, z);
					scene.add(m);
					resources.push({ mesh: m, pos: m.position.clone() });
					return m;
				}

				// ----------------------
				// 4) SOL / MONDE
				// ----------------------
				const planeSize = 400;
				GEOS.ground = new THREE.BoxGeometry(planeSize, 1, planeSize);
				const groundMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
				const ground = new THREE.Mesh(GEOS.ground, groundMat);
				ground.position.set(0, -0.5, 0);
				scene.add(ground);
				const groundShape = new AmmoLib.btBoxShape(
					new AmmoLib.btVector3(planeSize * 0.5, 0.5, planeSize * 0.5)
				);
				createRigidBody(ground, groundShape, 0);

				// Ressources initiales
				const INITIAL_RESOURCES = 12;
				for (let i = 0; i < INITIAL_RESOURCES; i++)
					spawnResource(
						(Math.random() - 0.5) * (planeSize - 4),
						(Math.random() - 0.5) * (planeSize - 4)
					);

				// ----------------------
				// 5) POPULATION INITIALE (4 factions × jusqu'à 3 unités)
				// ----------------------
				const spawnRadius = 6;
				for (let f = 0; f < 4; f++) {
					spawnAgent(
						"tank",
						f,
						(Math.random() - 0.5) * spawnRadius,
						7,
						(Math.random() - 0.5) * spawnRadius
					);
					spawnAgent(
						"dps",
						f,
						(Math.random() - 0.5) * spawnRadius,
						8,
						(Math.random() - 0.5) * spawnRadius
					);
					spawnAgent(
						"healer",
						f,
						(Math.random() - 0.5) * spawnRadius,
						9,
						(Math.random() - 0.5) * spawnRadius
					);
				}

				// ----------------------
				// 6) IA : Wander/Seek + vie/consommation
				// ----------------------
				function isGrounded(a) {
					a.body.getMotionState().getWorldTransform(TMP.trans);
					const y = TMP.trans.getOrigin().y();
					const vy = a.body.getLinearVelocity().y?.() || 0;
					return y <= 0.55 && Math.abs(vy) < 0.7;
				}

				function nearestResource(pos) {
					let best = null,
						bd = Infinity;
					for (const r of resources) {
						const d = pos.distanceTo(r.pos);
						if (d < bd) {
							bd = d;
							best = r;
						}
					}
					return [best, bd];
				}

				function removeResource(res) {
					const i = resources.indexOf(res);
					if (i >= 0) {
						scene.remove(res.mesh);
						resources.splice(i, 1);
					}
				}

				function steerWander(a, dt) {
					a.turnT -= dt;
					if (a.turnT <= 0) {
						a.turnT = 0.3 + Math.random() * 0.5;
						a.headingDeg =
							(a.headingDeg +
								(Math.random() * 2 - 1) * a.turnRate * 0.3 +
								360) %
							360;
					}
					const rad = (a.headingDeg * Math.PI) / 180;
					const ax = Math.sin(rad),
						az = Math.cos(rad);
					const vx = ax * a.speed,
						vz = az * a.speed;
					if (LOCK_MODE) {
						keepAnchored(a);
						return;
					}
					setVelocity(a.body, vx, 0, vz);
				}

				function steerSeek(a, target, dt) {
					const dir = new THREE.Vector3().subVectors(
						target,
						a.mesh.position
					);
					dir.y = 0;
					const d = dir.length();
					if (d > 0.0001) dir.normalize();
					const desiredDeg = (Math.atan2(dir.x, dir.z) * 180) / Math.PI; // [-180,180]
					let delta = desiredDeg - a.headingDeg;
					delta = ((delta + 540) % 360) - 180; // wrap to [-180,180]
					const maxTurn = a.turnRate * dt;
					if (delta > maxTurn) delta = maxTurn;
					if (delta < -maxTurn) delta = -maxTurn;
					a.headingDeg = (a.headingDeg + delta + 360) % 360;
					const rad = (a.headingDeg * Math.PI) / 180;
					const ax = Math.sin(rad),
						az = Math.cos(rad);
					const speed = a.speed * (d > 1 ? 1 : Math.max(0.2, d));
					if (LOCK_MODE) {
						keepAnchored(a);
						return;
					}
					setVelocity(a.body, ax * speed, 0, az * speed);
				}

				function keepInside(a) {
					const lim = planeSize * 0.5 - 1.0;
					const p = a.mesh.position;
					if (Math.abs(p.x) > lim || Math.abs(p.z) > lim) {
						const dirToCenter = (Math.atan2(-p.x, -p.z) * 180) / Math.PI;
						a.headingDeg = (dirToCenter + 360) % 360;
					}
				}

				function keepAnchored(a) {
					// Force la position à l'ancre et garde la rotation libre uniquement en Y
					if (!a.anchor)
						a.anchor = new THREE.Vector3(
							a.mesh.position.x,
							0.5,
							a.mesh.position.z
						);
					const b = a.body;
					const tr = TMP.trans;
					b.getMotionState().getWorldTransform(tr);
					tr.setOrigin(
						new AmmoLib.btVector3(
							a.anchor.x,
							a.anchor.y ?? 0.5,
							a.anchor.z
						)
					);
					if (typeof b.setWorldTransform === "function")
						b.setWorldTransform(tr);
					else if (typeof b.setCenterOfMassTransform === "function")
						b.setCenterOfMassTransform(tr);
				}

				function updateAgent(a, dt) {
					a.grounded = isGrounded(a);
					if (!a.grounded) return;
					a.hp -= 0.5 * dt;
					if (a.hp < 0) a.hp = 0;
					if (a.hp < 50 && resources.length > 0) a.state = "seek_resource";
					else a.state = "wander";
					if (a.state === "wander") steerWander(a, dt);
					else if (a.state === "seek_resource") {
						const [res, d] = nearestResource(a.mesh.position);
						if (res) {
							steerSeek(a, res.pos, dt);
							if (d < RES_PICK) {
								a.hp = Math.min(66, a.hp + RES_HEAL);
								removeResource(res);
							}
						} else {
							steerWander(a, dt);
						}
					}
					keepInside(a);
				}

				// ----------------------
				// 7) BOUCLE D'ANIMATION (zéro alloc par frame côté Ammo)
				// ----------------------
				let last = performance.now();
				function animate(now) {
					const dt = Math.min((now - last) / 1000, 1 / 30);
					last = now;
					physicsWorld.stepSimulation(dt, 10);

					const trans = TMP.trans; // réutilisé pour tous les rigid bodies
					for (const mesh of rigidBodies) {
						const body = mesh.userData.physicsBody;
						body.getMotionState().getWorldTransform(trans);
						const o = trans.getOrigin();
						const r = trans.getRotation();
						mesh.position.set(o.x(), o.y(), o.z());
						mesh.quaternion.set(r.x(), r.y(), r.z(), r.w());
					}

					for (const a of agents) {
						updateAgent(a, dt);
						faceMotion(a, dt);
						updateHat(a); // <- maintenir le chapeau au-dessus et droit
						if (LOCK_MODE) applyLockToAgent(a, true);
					}

					controls.update();
					clampCameraAboveGround();
					renderer.render(scene, camera);
					requestAnimationFrame(animate);
				}
				requestAnimationFrame(animate);

				// ----------------------
				// 8) RWD + UI + INPUTS
				// ----------------------
        const ui = document.createElement("div");
        ui.className = "ui";
        ui.innerHTML = `
        <b>Three.js + Ammo.js</b><br>
        4 factions (max 3 unités chacune)<br> • Rôles : <b>cube</b>=tank, <b>pyramide</b>=dps, <b>sphère</b>=healer<br>
        - Les corps <b>physiques sont tous des cubes</b>; un <b>chapeau</b> au-dessus indique le rôle<br>
        - Les agents <b>wandern</b> puis <b>cherchent une ressource</b> si HP < 50 (HP init 66, Énergie 99)<br>
        - <b>12 ressources</b> au sol (pas de repop)<br>
      `;
        document.body.appendChild(ui);
				addEventListener("resize", () => {
					camera.aspect = innerWidth / innerHeight;
					camera.updateProjectionMatrix();
					renderer.setSize(innerWidth, innerHeight);
				});


				function detectFallOverTime(mesh, ms = 1500, cb) {
					const start = performance.now();
					let lastY = mesh?.position?.y;
					let fell = false;
					function step() {
						const now = performance.now();
						const y = mesh?.position?.y;
						if (
							typeof lastY === "number" &&
							typeof y === "number" &&
							y < lastY - 0.0005
						)
							fell = true;
						lastY = y;
						if (now - start < ms) requestAnimationFrame(step);
						else cb(!!fell);
					}
					requestAnimationFrame(step);
				}

			});
		</script>
	</head>
	<body>
		<div id="app"></div>
	</body>
</html>
